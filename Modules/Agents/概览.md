# Agents-代理

一些应用程序将不仅需要对LLM/其他工具的预定调用链，而且可能需要取决于用户输入的未知链。在这些类型的链中，有一个“代理”可以访问一套工具。根据用户的输入，代理可以决定调用这些工具中的哪一个（如果有的话）。

目前，主要有两种类型核心代理：
- “Action Agents”-“行动代理”：这些代理决定要采取的操作，并一步一步地执行该操作

- “Plan-and-Execute Agents”-“计划和执行代理”：这些代理首先决定要采取的动作计划，然后一次执行一个动作。

什么时候应该使用哪一个？“行动代理”更传统，适合小任务。对于更复杂或长期运行的任务，最初的计划步骤有助于保持长期目标并且更聚焦。然而，这通常是以更多的调用和更高的延迟为代价的。这两个代理也不是相互排斥的-事实上，通常最好让一个“行动代理”负责Plan and Execute代理的执行。？？

## Action Agents
代理的高级伪代码看起来像这样：
- 接收一些用户输入
- 代理决定使用哪个工具（如果有的话），以及该工具的输入应该是什么
- 然后使用该工具输入调用该工具，并记录观察结果（这只是使用该工具输入调用该工具的输出）
- 工具、工具输入和观察的历史记录被传递回代理，并由代理决定下一步要采取什么步骤
- 重复此操作，直到代理决定不再需要使用工具，然后直接响应用户。


代理中涉及的不同抽象如下：

**代理：这是应用程序的逻辑所在。代理公开一个接口，该接口接受用户输入沿着代理执行的先前步骤的列表，并返回AgentAction或AgentFinish**
- AgentAction对应于要使用的工具和该工具的输入
- AgentFinish意味着代理已完成，并具有返回给用户的信息

**工具**：这些是代理可以执行的操作。你给予代理什么工具在很大程度上取决于你想让代理做什么

**工具包**：这些是为特定用例设计的工具组。例如，为了使代理以最佳方式与SQL数据库交互，它可能需要访问一个工具来执行查询，并访问另一个工具来检查表。
**代理执行器**：这包装了代理和工具列表。这负责循环迭代地运行代理直到满足停止条件。

上述四个概念中最重要的抽象概念是代理。虽然可以以任何方式定义代理，但构建代理的典型方式是：

- **提示模板**：这负责获取用户输入和先前的步骤，并构造prompt以发送到语言模型；
- **语言模型**：负责接受由PromptTemplate构造的prompt并返回一些输出；
- **输出解析器**：这将获取语言模型的输出并将其解析为AgentAction或AgentFinish对象。


在本节文档中，我们首先从入门笔记开始，介绍如何以端到端的方式使用与代理相关的所有内容。然后，我们将文档分为以下几个部分：

#### Tools 工具
在本节中，我们将介绍LangChain原生支持的不同类型的工具。然后我们将介绍如何添加自己的工具。

#### Agents 代理
在本节中，我们将介绍LangChain本地支持的不同类型的代理。然后，我们将介绍如何修改和创建自己的代理。

#### Toolkits 工具包
在本节中，我们将介绍LangChain支持的各种开箱即用的工具包，以及如何从它们创建代理。



#### Agent Executor 代理执行器
在本节中，我们将介绍Agent Executor类，它负责在循环中调用代理和工具。我们将介绍不同的自定义方法，以及您可以用于更多控制的选项。


#### 深入了解
- [Tools](../Agents/工具/概览.md)
- [Agents](../Agents/代理/概览.md)
- [Toolkits](../Agents/工具包/概览.md)
- [Agent Executors](../Agents/代理执行器/概览.md)


## Plan-and-Execute Agents 计划和执行代理
代理的高级伪代码看起来像这样：
- 接收一些用户输入
- 规划器列出了要采取的步骤
- 执行器遍历步骤列表，执行它们

最典型的实现是让语言模型作为规划器，而执行器是动作代理。



#### Go Deeper

Plan and Execute  
Imports
Tools
Planner, Executor, and Agent  
Run Example